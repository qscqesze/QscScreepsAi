/*
 * ROLE: CHARGER
 *
 * A charger moves energy from a storage or container into structures that need energy.
 *
 * Your creep has a "weight" which is determined by the total number of body parts, not 
 * including move parts or carry parts that aren't full of a resource. Every time you move 
 * fatigue is generated by taking your weight and multiplying by the terrain factor: 2 for
 * plains, 10 for swamps, and 1 for roads. At the end of every turn 2 fatigue is 
 * subtracted for each move part you have. This subtraction happens after fatigue is 
 * generated so if you have equal move and weight you net 0 fatigue.
 * 
 */

module.exports = {

    create: function(spawn, creepName, size, args) {

        var bodies = {
            'xsmall': {
                energy: 300, 
                def: [CARRY,CARRY,CARRY,MOVE,MOVE,MOVE]
            },
            'small':  {
                energy: 500, 
                def: [CARRY,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE]
            },
            // move at half speed now, needs roads
            'medium': {
                energy: 750, 
                def: [CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,
                    MOVE,MOVE,MOVE,MOVE,MOVE]
            },
            'large':  {
                energy: 1300, 
                def: [CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,
                    CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,
                    MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE]
            },
            'xlarge': {
                energy: 1800, 
                def: [CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,
                    CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,
                    CARRY,CARRY,CARRY,CARRY,
                    MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE]
            },
        };
    
        // do we have enough energy to create the requested size of unit?
        if (spawn.room.energyAvailable < bodies[size].energy) {
            return false;
        }

        var attrs = {role: 'charger', mode: 'pickup', target: null};

        var spawnResult = spawn.spawnCreep(bodies[size].def, creepName, {memory: attrs});
        if (spawnResult == OK) {
            console.log(spawn.name + ' new ' + size + ' creep: ' + creepName);
            return true;
        }

        return false;
    },

    run: function(creep) {
        
        // mode switching (pickup, dropoff)
        if (creep.memory.mode == 'pickup' && creep.carry.energy == creep.carryCapacity) {
            // when creep is full of energy, switch modes
            creep.memory.mode = 'dropoff';
            creep.memory.target = null;
        } else if (creep.memory.mode == 'dropoff' && creep.carry.energy == 0) {
            // when creep is out of energy, switch modes
            creep.memory.mode = 'pickup';
            creep.memory.target = null;
        }

        // load the saved target
        var target = null;
        if (creep.memory.target != null) {
            target = Game.getObjectById(creep.memory.target);
        }
        
        // keep track of how much this creep is carrying so we can perform the most 
        // possible in one tick
        var creepCarryAmount = creep.carry[RESOURCE_ENERGY];
        var oldTargetId = null;

        // ACTION FIRST
        [target, creepCarryAmount, oldTargetId] = 
            this.action(creep, target, creepCarryAmount, oldTargetId);

        // TARGET ACQUISITION SECOND
        target = this.target(creep, target, creepCarryAmount, oldTargetId);

        // MOVEMENT THIRD
        this.movement(creep, target);

    },

    action: function(creep, target, creepCarryAmount, oldTargetId) {
        
        if (creep.memory.mode == 'dropoff' && target != null) {

            var result = creep.transfer(target, RESOURCE_ENERGY);
            switch(result) {
                case ERR_NOT_IN_RANGE:
                    break;
                case ERR_NOT_ENOUGH_RESOURCES:
                    creep.memory.mode = 'pickup';
                    target = null;
                    creep.memory.target = null;
                    break;
                case ERR_INVALID_TARGET:
                case ERR_FULL:
                    target = null;
                    creep.memory.target = null;
                    break;
                case OK:
                    // prevent target lookup from picking the same structure we just 
                    // filled up
                    oldTargetId = target.id;
    
                    // switch to pickup if we emptied ourselves
                    if (target.energyCapacity) {
                        creepCarryAmount -= target.energyCapacity;
                        if (creepCarryAmount <= 0) {
                            creep.memory.mode = 'pickup';
                        }
                    }
    
                    target = null;
                    creep.memory.target = null;
                    break;
                default:
                    creep.say(result);
                    break;
            }
    
        }
    
        // refill on more resources
        if (creep.memory.mode == 'pickup' && target != null) {
    
            if (target instanceof Resource) {
                // picking up dropped energy
                var result = creep.pickup(target);
                switch(result) {
                    case ERR_NOT_IN_RANGE:
                        break;
                    case ERR_NOT_ENOUGH_RESOURCES:
                        // pile empty, so find another one next tick
                        target = null;
                        creep.memory.target = null;
                        break;
                    case OK:
                        creepCarryAmount += target.amount;
                        if (creepCarryAmount >= creep.carryCapacity) {
                            creep.memory.mode = 'dropoff';
                            creepCarryAmount = creep.carryCapacity;
                        }
                        target = null;
                        creep.memory.target = null;
                        break;
                    default:
                        creep.say(result);
                        break;
                }
            } else {
                // pulling from container or storage
                switch(creep.withdraw(target, RESOURCE_ENERGY)) {
                    case ERR_NOT_IN_RANGE:
                        break;
                    case ERR_NOT_ENOUGH_RESOURCES:
                        // this container is empty, so find another one next tick
                        target = null;
                        creep.memory.target = null;
                        break;
                    case OK:
                        creepCarryAmount += target.store[RESOURCE_ENERGY];
                        if (creepCarryAmount >= creep.carryCapacity) {
                            creep.memory.mode = 'dropoff';
                            creepCarryAmount = creep.carryCapacity;
                        }
                        target = null;
                        creep.memory.target = null;
                        break;
                    default:
                        creep.say(result);
                        break;
                }
            }
    
        }
        
        // return multiple variables so that target() can use them
        return [target, creepCarryAmount, oldTargetId];
    },

    target: function(creep, target, creepCarryAmount, oldTargetId) {
        
        if (creep.memory.mode == 'pickup' && target == null) {
    
            // if the storage is well off, pull from there
            if (creep.room.storage && creep.room.storage.store[RESOURCE_ENERGY] > 1000) {
                // if we're about to die, suicide instead of pulling from storage
                if (creep.ticksToLive < 20) {
                    creep.suicide();
                } else {
                    target = creep.room.storage;
                    creep.memory.target = target.id;
                }
            } else {
    
                // find all containers with energy in them
                // find the fullest container, b - a for desc order
                var containers = creep.room.find(FIND_STRUCTURES, {
                    filter: (structure) => {
                        return (structure.structureType == STRUCTURE_CONTAINER && 
                            structure.store[RESOURCE_ENERGY] > 0);
                    }
                }).sort(function(a, b) { 
                    return b.store[RESOURCE_ENERGY] - a.store[RESOURCE_ENERGY]; 
                });

                if (containers.length > 0) {
                    // remember the container we are going to pull from
                    target = containers[0];
                    creep.memory.target = target.id;
                } else {
                    // find the fullest pile
                    var droppedEnergy = creep.room.find(FIND_DROPPED_RESOURCES, {
                                filter: (resource) => {
                                    return (resource.resourceType == RESOURCE_ENERGY);
                                }
                        }).sort(function(a, b) { return b.amount - a.amount; });
                    if (droppedEnergy.length > 0) {
                        // remember the pile we are going to pull from
                        target = droppedEnergy[0];
                        creep.memory.target = target.id;
                    }
                }
            }
    
        } else if (creep.memory.mode == 'dropoff' && target == null) {
    
            // give towers priority
            target = creep.pos.findClosestByRange(FIND_MY_STRUCTURES, {
                        filter: (structure) => {
                            return (structure.structureType == STRUCTURE_TOWER) && 
                                    structure.energy < structure.energyCapacity - 200 &&
                                    structure.id != oldTargetId;
                        }
            });
            
            // if no tower is asking for help, find the nearest structure that doesn't
            // have full energy
            if (target == null) {
                target = creep.pos.findClosestByRange(FIND_MY_STRUCTURES, {
                            filter: (structure) => {
                                return (structure.structureType == STRUCTURE_EXTENSION ||
                                        structure.structureType == STRUCTURE_SPAWN) && 
                                        structure.energy < structure.energyCapacity &&
                                        structure.id != oldTargetId;
                            }
                });
            }
            
            // remember the structure we are filling up
            if (target != null) {
                creep.memory.target = target.id;
            } else if (creep.carry.energy < creep.carryCapacity) {
    
                // nowhere needs energy right now, so use the break to refill ourselves
                creep.memory.mode = 'pickup';
                // whenever we change mode, the target should be reset.
                // will do a real lookup next tick, but take a first step toward storage
                target = creep.room.storage; 
                creep.memory.target = null;
    
            } else {
                
                // if we're about to die, drop our load back into storage
                if (creep.ticksToLive <= 20 && creep.room.storage) {
                    target = creep.room.storage;
                    creep.memory.target = target.id;
                } else {
                    // we have nothing to do
                    // go rest near the spawn
                    var spawns = creep.room.find(FIND_MY_STRUCTURES, {
                        filter: { structureType: STRUCTURE_SPAWN }
                    });
        
                    if (spawns.length > 0) {
                        target = spawns[0];
                    }
                }
    
            }
    
        }
        
        return target;
    },

    movement: function(creep, target) {

        if (target != null) {
            creep.moveTo(target);
        }
      
    },

};